use std::{thread::sleep, time::Duration};

//структура
struct Example(i32);

//реализация Drop для сруктуры Example
impl Drop for Example {
    fn drop(&mut self) {
        println!("{}", self.0);
    }
}
//структура обертка на структурой Example
struct ExampleWrap(Example);

//реализация Drop для сруктуры ExampleWrap

impl Drop for ExampleWrap {
    fn drop(&mut self) {
        //Заменяем в стурктуре ExampleWrap структуру Example на Example(0)
        //при этом "старая структура закинута в перменную e"
        let e = std::mem::replace(&mut self.0, Example(0));
        //Вывод в консоль занчения из "старой" структуры Example в консоль
        println!("wrap {}", e.0);
        //"cтарая" структура Example дропается
    }
}

fn main() {
    //создется структура и сразу же дропается, выводя в консоль 1 (будет первым элементом в консоль)
    Example(1);

    //Переменной e2 присваиваем структру, при этом компилятор дропает
    //структуру после выхода из scope, выводя в консоль 2 (будет 9 элементом в консоли и будет дропаться в последней при выходе из scope)
    let _e2 = Example(2);

    //Переменной e3 присваиваем структру, при этом компилятор дропает
    //сразу структуру после выхода из scope, выводя в консоль 3 (будет 8 элементом в консоли и будет дропаться первой из выхода из scope)
    let _e3 = Example(3);

    //Переменной e4 присваиваем структру, при этом компилятор дропает сразу структуру после создания, выводя в консоль 4 (будет вторым элементом в консоли)
    let _ = Example(4);

    //объявляем mut переменную _e5
    let mut _e5;

    //присваиваем перменной e5 Some
    _e5 = Some(Example(5));

    //присваиваем перменной e5 None, при этом будет вызван деструктор и в консоль выведeтся 5 (будет 3 элементом в консоли)
    _e5 = None;
    //sleep(Duration::from_secs(5));
    //присваиваем перменной e6 структуру Example
    let e6 = Example(6);

    //дропаем переменую e6, выводя в консоль 6 (будет 4 элементом в консоли)
    drop(e6);

    //присваиваем перменной e7 структуру Example
    let e7 = Example(7);
    //говорим компилятору что при выходе из области видимости не дропать это значение(в консоль ничего не выведется)
    std::mem::forget(e7);
    sleep(Duration::from_secs(1));

    //создется структура и сразу же дропается, выводя в консоль консоль сначала wrap 8 (Drop для ExampleWrap и будет 5 элементом в консоли)
    //,а затем 8 (Drop для Example и будет 6 элементом в консоли)
    //а затем 0 (т.к. Drop уже был вызван для ExampleWrap, и остался Example (0)=> и делается Drop для Example и будет 7 элементом в консоли)
    ExampleWrap(Example(8));
}
//Вывод программы
//1, 4, 5, 6, wrap 8, 8 , 0 , 3, 2

//Уровни дропа
// 1) Без инициализации переменной(_ или SomeSctruct(...)) сразу же ( при этом в том порялке в котором объвлены в scope)
// 2) drop() в том порядке в котором объявлены scope
// 3) при переприсвоении переменной высвобождается "значение" и получается как в п.№1
// 4) В случает let_1=... только при выходе из scope по принципу LIFO
